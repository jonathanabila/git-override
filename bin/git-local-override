#!/usr/bin/env bash
#
# git-local-override - Utility for managing local file overrides
#
# This tool helps manage local modifications to tracked files.
# Configuration is stored in .local-overrides.yaml in your repository.
#
# The main functionality is provided by git hooks (installed separately).
# This CLI provides utility commands for managing override files.
#
# WHY CLI IS SEPARATE FROM HOOKS:
# The CLI is optional - hooks work independently. This allows users who only
# need basic functionality to skip CLI installation entirely. The CLI adds
# convenience commands (add, remove, list, status) but isn't required.
#
# NOTE ON CODE DUPLICATION:
# read_config() and get_local_path() are duplicated from local-override-lib.sh.
# This is intentional: the CLI must work standalone without the hooks installed,
# so it cannot source the lib file (which lives in .git/hooks/).
#
set -euo pipefail

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

#------------------------------------------------------------------------------
# Utility Functions
#------------------------------------------------------------------------------

die() {
    echo -e "${RED}Error:${NC} $*" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}Warning:${NC} $*" >&2
}

info() {
    echo -e "${BLUE}Info:${NC} $*"
}

success() {
    echo -e "${GREEN}Success:${NC} $*"
}

# Get the root directory of the current git repository
get_repo_root() {
    git rev-parse --show-toplevel 2>/dev/null || die "Not in a git repository"
}

# Read the pattern field from config file
# Returns the pattern string, or empty if not found
read_pattern() {
    local repo_root="$1"
    local config_file="$repo_root/.local-overrides.yaml"

    [[ -f "$config_file" ]] || return 0

    local line
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" == \#* ]] && continue
        # Match pattern: "pattern: .something" or 'pattern: ".something"'
        if [[ "$line" =~ ^pattern:[[:space:]]*(.+)$ ]]; then
            local pattern="${BASH_REMATCH[1]}"
            # Remove quotes if present
            pattern="${pattern#\"}"
            pattern="${pattern%\"}"
            pattern="${pattern#\'}"
            pattern="${pattern%\'}"
            # Trim whitespace
            pattern="${pattern#"${pattern%%[![:space:]]*}"}"
            pattern="${pattern%"${pattern##*[![:space:]]}"}"
            echo "$pattern"
            return
        fi
    done < "$config_file"
}

# Validate config file format
# Returns 0 if valid, 1 if invalid (missing required fields)
# Outputs warning/error messages to stderr
validate_config() {
    local repo_root="$1"
    local pattern
    pattern="$(read_pattern "$repo_root")"

    # Check if using plain text format (legacy, no pattern support)
    if [[ -f "$repo_root/.local-overrides" && ! -f "$repo_root/.local-overrides.yaml" ]]; then
        warn "Plain text .local-overrides does not support patterns."
        echo "  Migrate to .local-overrides.yaml with 'pattern:' field." >&2
        return 1
    fi

    # Check if YAML config exists but pattern is missing
    if [[ -f "$repo_root/.local-overrides.yaml" && -z "$pattern" ]]; then
        warn "Missing required 'pattern:' field in .local-overrides.yaml"
        echo "  Add a pattern field at the top of your config:" >&2
        echo "    pattern: \".local\"" >&2
        echo "    files:" >&2
        echo "      - CLAUDE.md" >&2
        return 1
    fi

    return 0
}

# Convert path to local override path using specified pattern
# e.g., get_local_path "AGENTS.md" ".override" -> AGENTS.override.md
#       get_local_path "Makefile" ".local" -> Makefile.local
#
# Arguments:
#   $1 - original file path
#   $2 - pattern to use (e.g., ".override", ".local") - defaults to ".local"
get_local_path() {
    local path="$1"
    local pattern="${2:-.local}"
    local dir basename ext

    # Remove leading dot from pattern for insertion
    local pattern_infix="${pattern#.}"

    dir="$(dirname "$path")"
    basename="$(basename "$path")"

    if [[ "$basename" == *.* ]]; then
        ext="${basename##*.}"
        basename="${basename%.*}"
        if [[ "$dir" == "." ]]; then
            echo "${basename}.${pattern_infix}.${ext}"
        else
            echo "${dir}/${basename}.${pattern_infix}.${ext}"
        fi
    else
        if [[ "$dir" == "." ]]; then
            echo "${basename}.${pattern_infix}"
        else
            echo "${dir}/${basename}.${pattern_infix}"
        fi
    fi
}

# Normalize a path to be relative to repo root
normalize_path() {
    local path="$1"
    local repo_root
    repo_root="$(get_repo_root)"

    # If path is absolute, make it relative to repo root
    if [[ "$path" == /* ]]; then
        path="${path#$repo_root/}"
    fi

    # Remove leading ./ if present
    path="${path#./}"

    echo "$path"
}

# Read config file and output list of override-able files
#
# Output format: path|override_path
#   - For simple entries: "CLAUDE.md|" (empty override_path)
#   - For explicit overrides: "config.json|config.mylocal.json"
#
# YAML supports two formats:
#   Simple: - CLAUDE.md
#   Explicit: - path: config.json
#               override: config.mylocal.json
read_config() {
    local repo_root="$1"
    local config_file=""
    local in_files_section=false
    local pending_path=""

    # Check for config files in order of preference
    if [[ -f "$repo_root/.local-overrides.yaml" ]]; then
        config_file="$repo_root/.local-overrides.yaml"

        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" == \#* ]] && continue

            # Check for files: section start
            if [[ "$line" =~ ^files:[[:space:]]*$ ]]; then
                in_files_section=true
                continue
            fi

            # Skip pattern: line
            if [[ "$line" =~ ^pattern: ]]; then
                continue
            fi

            # Stop if we hit another top-level key (non-indented, ends with :)
            if [[ "$line" =~ ^[a-z_]+:[[:space:]]*$ && ! "$line" =~ ^[[:space:]] ]]; then
                in_files_section=false
                continue
            fi

            [[ "$in_files_section" != true ]] && continue

            # Handle per-file override: "  - path: config.json"
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]+path:[[:space:]]+(.+)$ ]]; then
                # Emit any pending path without override first
                if [[ -n "$pending_path" ]]; then
                    echo "${pending_path}|"
                fi
                pending_path="${BASH_REMATCH[1]}"
                # Clean up quotes and whitespace
                pending_path="${pending_path#\"}"
                pending_path="${pending_path%\"}"
                pending_path="${pending_path#\'}"
                pending_path="${pending_path%\'}"
                pending_path="${pending_path#"${pending_path%%[![:space:]]*}"}"
                pending_path="${pending_path%"${pending_path##*[![:space:]]}"}"
                continue
            fi

            # Handle override: line (must follow path: line)
            if [[ -n "$pending_path" && "$line" =~ ^[[:space:]]+override:[[:space:]]+(.+)$ ]]; then
                local override="${BASH_REMATCH[1]}"
                override="${override#\"}"
                override="${override%\"}"
                override="${override#\'}"
                override="${override%\'}"
                override="${override#"${override%%[![:space:]]*}"}"
                override="${override%"${override##*[![:space:]]}"}"
                echo "${pending_path}|${override}"
                pending_path=""
                continue
            fi

            # Handle simple list entry: "  - CLAUDE.md"
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]+(.+)$ ]]; then
                # Emit any pending path without override first
                if [[ -n "$pending_path" ]]; then
                    echo "${pending_path}|"
                    pending_path=""
                fi

                local file="${BASH_REMATCH[1]}"
                # Skip if this is a path: entry (already handled above)
                if [[ "$file" =~ ^path: ]]; then
                    continue
                fi
                file="${file#\"}"
                file="${file%\"}"
                file="${file#\'}"
                file="${file%\'}"
                file="${file#"${file%%[![:space:]]*}"}"
                file="${file%"${file##*[![:space:]]}"}"
                [[ -n "$file" ]] && echo "${file}|"
            fi
        done < "$config_file"

        # Emit any trailing pending path
        if [[ -n "$pending_path" ]]; then
            echo "${pending_path}|"
        fi

    elif [[ -f "$repo_root/.local-overrides" ]]; then
        config_file="$repo_root/.local-overrides"
        # Plain text - one file per line (no explicit override support)
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" == \#* ]] && continue
            # Trim whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            line="${line%"${line##*[![:space:]]}"}"
            [[ -n "$line" ]] && echo "${line}|"
        done < "$config_file"
    fi
    # No config file = no overrides
}

# Check if file is in config and get its override path if any
# Returns 0 if found, 1 if not found
# If found, outputs "path|override_path" to stdout
is_in_config() {
    local path="$1"
    local repo_root="$2"

    local entry config_path
    while IFS= read -r entry || [[ -n "$entry" ]]; do
        [[ -z "$entry" ]] && continue
        config_path="${entry%%|*}"
        if [[ "$config_path" == "$path" ]]; then
            echo "$entry"
            return 0
        fi
    done < <(read_config "$repo_root")

    return 1
}

# Get override path for a file (either explicit or pattern-based)
# Arguments:
#   $1 - file path
#   $2 - config entry (path|override_path format)
#   $3 - pattern
get_override_path() {
    local path="$1"
    local entry="$2"
    local pattern="$3"

    local override_path="${entry#*|}"
    if [[ -n "$override_path" ]]; then
        echo "$override_path"
    else
        get_local_path "$path" "$pattern"
    fi
}

#------------------------------------------------------------------------------
# Commands
#------------------------------------------------------------------------------

cmd_add() {
    local path="${1:-}"

    if [[ -z "$path" ]]; then
        die "Usage: git-local-override add <path>"
    fi

    local repo_root
    repo_root="$(get_repo_root)"
    path="$(normalize_path "$path")"

    local full_path="$repo_root/$path"

    # Check if file exists
    if [[ ! -f "$full_path" ]]; then
        die "File does not exist: $path"
    fi

    # Read pattern and validate config
    local pattern
    pattern="$(read_pattern "$repo_root")"
    if ! validate_config "$repo_root"; then
        # For backwards compatibility, continue with .local default
        pattern=".local"
    fi

    # Check if file is in config and get entry
    local config_entry local_path
    if config_entry=$(is_in_config "$path" "$repo_root"); then
        local_path="$(get_override_path "$path" "$config_entry" "$pattern")"
    else
        warn "'$path' is not in .local-overrides.yaml"
        echo "  Add it to .local-overrides.yaml to enable override:"
        echo "    pattern: \"$pattern\""
        echo "    files:"
        echo "      - $path"
        echo ""
        local_path="$(get_local_path "$path" "$pattern")"
    fi

    local full_local_path="$repo_root/$local_path"

    # Create the local override file if it doesn't exist
    if [[ ! -f "$full_local_path" ]]; then
        cp "$full_path" "$full_local_path"
        info "Created local override file: $local_path"
    else
        info "Local override file already exists: $local_path"
    fi

    # Apply the override (copy local content to original)
    cp "$full_local_path" "$full_path"

    success "Override active for: $path"
    echo "  Edit your local version: $local_path"
    echo "  Git will see the original content, you see your local version"
}

cmd_remove() {
    local path="${1:-}"
    local delete_file=false

    if [[ "$path" == "--delete" || "$path" == "-d" ]]; then
        delete_file=true
        path="${2:-}"
    fi

    if [[ -z "$path" ]]; then
        die "Usage: git-local-override remove [-d|--delete] <path>"
    fi

    local repo_root
    repo_root="$(get_repo_root)"
    path="$(normalize_path "$path")"

    # Read pattern and validate config
    local pattern
    pattern="$(read_pattern "$repo_root")"
    if ! validate_config "$repo_root"; then
        pattern=".local"
    fi

    # Get override path from config or use pattern
    local config_entry local_path
    if config_entry=$(is_in_config "$path" "$repo_root"); then
        local_path="$(get_override_path "$path" "$config_entry" "$pattern")"
    else
        local_path="$(get_local_path "$path" "$pattern")"
    fi

    local full_path="$repo_root/$path"
    local full_local_path="$repo_root/$local_path"

    # Restore original content from git
    if git -C "$repo_root" ls-files --error-unmatch "$path" &>/dev/null; then
        git -C "$repo_root" checkout HEAD -- "$path" 2>/dev/null || true
        info "Restored original content: $path"
    fi

    # Optionally delete the local file
    if [[ "$delete_file" == true && -f "$full_local_path" ]]; then
        rm "$full_local_path"
        info "Deleted local override file: $local_path"
    elif [[ -f "$full_local_path" ]]; then
        info "Local override file preserved: $local_path"
        echo "  Use -d/--delete to also remove the local file"
    fi

    success "Override removed for: $path"
}

cmd_list() {
    local repo_root
    repo_root="$(get_repo_root)"

    # Check for config file
    if [[ ! -f "$repo_root/.local-overrides.yaml" && ! -f "$repo_root/.local-overrides" ]]; then
        echo "No .local-overrides.yaml found in repository"
        echo ""
        echo "Create one to define which files can be overridden:"
        echo "  pattern: \".local\""
        echo "  files:"
        echo "    - CLAUDE.md"
        echo "    - AGENTS.md"
        return 0
    fi

    # Read pattern and validate config
    local pattern
    pattern="$(read_pattern "$repo_root")"
    if ! validate_config "$repo_root"; then
        pattern=".local"
    fi

    echo "Configured overrides in $(basename "$repo_root"):"
    echo "Pattern: $pattern"
    echo ""

    local count=0
    local active=0
    local entry path override_path local_path
    while IFS= read -r entry || [[ -n "$entry" ]]; do
        [[ -z "$entry" ]] && continue

        # Parse entry: "path|override_path"
        path="${entry%%|*}"
        override_path="${entry#*|}"

        # Determine local file path
        if [[ -n "$override_path" ]]; then
            local_path="$override_path"
        else
            local_path="$(get_local_path "$path" "$pattern")"
        fi

        local status=""
        if [[ -f "$repo_root/$local_path" ]]; then
            status="${GREEN}[active]${NC}"
            ((active++)) || true
        else
            status="${YELLOW}[no local file]${NC}"
        fi

        echo -e "  $path  $status"
        if [[ -f "$repo_root/$local_path" ]]; then
            echo -e "    -> $local_path"
        fi
        # Show if using explicit override
        if [[ -n "$override_path" ]]; then
            echo -e "    ${BLUE}(explicit override)${NC}"
        fi
        ((count++)) || true
    done < <(read_config "$repo_root")

    echo ""
    echo "Total: $count configured, $active active"
}

cmd_status() {
    local repo_root
    repo_root="$(get_repo_root)"

    echo "Local Override Status"
    echo "====================="
    echo ""
    echo "Repository: $repo_root"
    echo ""

    # Check for config file
    if [[ -f "$repo_root/.local-overrides.yaml" ]]; then
        echo -e "Config:     ${GREEN}.local-overrides.yaml${NC}"
        local pattern
        pattern="$(read_pattern "$repo_root")"
        if [[ -n "$pattern" ]]; then
            echo -e "Pattern:    ${GREEN}$pattern${NC}"
        else
            echo -e "Pattern:    ${YELLOW}not set (required)${NC}"
        fi
    elif [[ -f "$repo_root/.local-overrides" ]]; then
        echo -e "Config:     ${YELLOW}.local-overrides${NC} (legacy format)"
        echo -e "Pattern:    ${YELLOW}.local (default)${NC}"
    else
        echo -e "Config:     ${YELLOW}not found${NC}"
        echo ""
        echo "Create .local-overrides.yaml to configure overrides:"
        echo "  pattern: \".local\""
        echo "  files:"
        echo "    - CLAUDE.md"
        return 0
    fi

    # Check if hooks are installed
    local hooks_installed=true
    local hook_type
    for hook_type in post-checkout pre-commit post-commit; do
        local hook_file="$repo_root/.git/hooks/$hook_type"
        if [[ ! -f "$hook_file" ]] || ! grep -q "local-override" "$hook_file" 2>/dev/null; then
            hooks_installed=false
            break
        fi
    done

    if [[ "$hooks_installed" == true ]]; then
        echo -e "Hooks:      ${GREEN}installed${NC}"
    else
        echo -e "Hooks:      ${YELLOW}not installed${NC}"
        echo ""
        echo "Install hooks with one of:"
        echo "  - pre-commit install --hook-type pre-commit --hook-type post-commit --hook-type post-checkout"
        echo "  - curl -fsSL https://.../install.sh | bash"
    fi

    echo ""
    cmd_list
}

cmd_apply() {
    local repo_root
    repo_root="$(get_repo_root)"

    if [[ ! -f "$repo_root/.local-overrides.yaml" && ! -f "$repo_root/.local-overrides" ]]; then
        die "No .local-overrides.yaml found"
    fi

    # Read pattern and validate config
    local pattern
    pattern="$(read_pattern "$repo_root")"
    if ! validate_config "$repo_root"; then
        pattern=".local"
    fi

    info "Applying all overrides..."

    local count=0
    local entry path override_path local_path
    while IFS= read -r entry || [[ -n "$entry" ]]; do
        [[ -z "$entry" ]] && continue

        # Parse entry: "path|override_path"
        path="${entry%%|*}"
        override_path="${entry#*|}"

        # Determine local file path
        if [[ -n "$override_path" ]]; then
            local_path="$override_path"
        else
            local_path="$(get_local_path "$path" "$pattern")"
        fi

        local full_path="$repo_root/$path"
        local full_local_path="$repo_root/$local_path"

        if [[ -f "$full_local_path" && -f "$full_path" ]]; then
            cp "$full_local_path" "$full_path"
            echo "  Applied: $path"
            ((count++)) || true
        fi
    done < <(read_config "$repo_root")

    success "Applied $count override(s)"
}

cmd_restore() {
    local repo_root
    repo_root="$(get_repo_root)"

    if [[ ! -f "$repo_root/.local-overrides.yaml" && ! -f "$repo_root/.local-overrides" ]]; then
        die "No .local-overrides.yaml found"
    fi

    # Read pattern and validate config
    local pattern
    pattern="$(read_pattern "$repo_root")"
    if ! validate_config "$repo_root"; then
        pattern=".local"
    fi

    info "Restoring all originals..."

    local count=0
    local entry path override_path local_path
    while IFS= read -r entry || [[ -n "$entry" ]]; do
        [[ -z "$entry" ]] && continue

        # Parse entry: "path|override_path"
        path="${entry%%|*}"
        override_path="${entry#*|}"

        # Determine local file path
        if [[ -n "$override_path" ]]; then
            local_path="$override_path"
        else
            local_path="$(get_local_path "$path" "$pattern")"
        fi

        # Only restore if there's a local override
        if [[ -f "$repo_root/$local_path" ]]; then
            if git -C "$repo_root" ls-files --error-unmatch "$path" &>/dev/null; then
                git -C "$repo_root" checkout HEAD -- "$path" 2>/dev/null || true
                echo "  Restored: $path"
                ((count++)) || true
            fi
        fi
    done < <(read_config "$repo_root")

    success "Restored $count file(s)"
}

cmd_init_config() {
    local repo_root
    repo_root="$(get_repo_root)"

    local config_file="$repo_root/.local-overrides.yaml"

    if [[ -f "$config_file" ]]; then
        info "Config file already exists: $config_file"
        return 0
    fi

    cat > "$config_file" << 'EOF'
# Local Override Configuration
#
# pattern: Required. The suffix used for override files.
#          Example: ".local" means CLAUDE.md -> CLAUDE.local.md
#
# files: List of files that can have local overrides.
#        Simple format: just the filename
#        Advanced format: path + explicit override name

pattern: ".local"
files:
  - CLAUDE.md
  - AGENTS.md
  # Example of explicit override naming:
  # - path: config.json
  #   override: config.mylocal.json
EOF

    success "Created: $config_file"
    echo ""
    echo "Edit this file to configure your overrides."
    echo "The 'pattern:' field is required."
}

cmd_help() {
    cat << 'EOF'
git-local-override - Manage local file overrides

USAGE:
    git-local-override <command> [options]

COMMANDS:
    add <path>              Create a local override file for a tracked file
    remove [-d] <path>      Remove an override (-d to delete local file too)
    list                    List all configured overrides
    status                  Show detailed status
    apply                   Manually apply all overrides
    restore                 Manually restore all originals from git
    init-config             Create a .local-overrides.yaml template
    help                    Show this help message

EXAMPLES:
    # Create a local override for CLAUDE.md
    git-local-override add CLAUDE.md

    # Edit your local version (using the configured pattern)
    vim CLAUDE.local.md

    # See what's configured
    git-local-override list

    # Manually apply overrides (hooks do this automatically)
    git-local-override apply

    # Restore originals (hooks do this before commits)
    git-local-override restore

CONFIG FORMAT:
    The .local-overrides.yaml requires a 'pattern:' field:

      pattern: ".local"      # Required: suffix for override files
      files:
        - CLAUDE.md          # -> CLAUDE.local.md
        - AGENTS.md          # -> AGENTS.local.md
        - path: config.json  # Explicit override name:
          override: config.mylocal.json

    The pattern determines the override file naming:
      pattern: ".local"    -> CLAUDE.local.md
      pattern: ".override" -> CLAUDE.override.md
      pattern: ".custom"   -> CLAUDE.custom.md

HOW IT WORKS:
    1. Repository maintainer creates .local-overrides.yaml with pattern and files
    2. Users create override files using the configured pattern
    3. Git hooks automatically:
       - Show local content in working tree
       - Commit original content
       - Restore local content after commits

INSTALLATION:
    Hooks can be installed via:

    Pre-commit (recommended for teams):
      Add to .pre-commit-config.yaml:
        repos:
          - repo: https://github.com/jonathanabila/git-override
            rev: v1.0.0
            hooks:
              - id: local-override-pre-commit
              - id: local-override-post-commit
              - id: local-override-post-checkout

      Then run:
        pre-commit install --hook-type pre-commit --hook-type post-commit --hook-type post-checkout

    Standalone:
      curl -fsSL https://.../install.sh | bash
EOF
}

#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        add)            cmd_add "$@" ;;
        remove|rm)      cmd_remove "$@" ;;
        list|ls)        cmd_list "$@" ;;
        status)         cmd_status "$@" ;;
        apply)          cmd_apply "$@" ;;
        restore)        cmd_restore "$@" ;;
        init-config)    cmd_init_config "$@" ;;
        help|--help|-h) cmd_help ;;
        *)              die "Unknown command: $cmd. Run 'git-local-override help' for usage." ;;
    esac
}

main "$@"
